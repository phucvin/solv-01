<html>

$$$SOLV_SSR$$$

<script>
    const SOLV_CID = $$$SOLV_CID$$$;

    function assert(predicate, ...args) {
        if (!predicate) {
            console.error(...args);
            throw new Error('Assertion error, check console.');
        }
    }

    function setProperty(prop, value, el) {
        if (value === true) {
            el.setAttribute(prop, "");
        } else {
            el.setAttribute(prop, value);
        }
        el[prop] = value;
    }

    function removeProperty(prop, el) {
        if (el.tagName == 'INPUT' && prop == 'value') {
            el[prop] = '';
        } else {
            el[prop] = undefined;
        }
        el.removeAttribute(prop);
    }

    function setListener(el, event, handle) {
        el.setAttribute('on' + event, 'dispatch(' + JSON.stringify(handle) + ')');
    }

    function eventName(str) {
        if (str.indexOf('on') == 0) {
            return str.slice(2).toLowerCase();
        }
        return null;
    }

    function create(vnode) {
        if (vnode.text !== undefined) {
            const el = document.createTextNode(vnode.text);
            return el;
        }

        const el = document.createElement(vnode.tag);

        for (const prop in vnode.properties) {
            const event = eventName(prop);
            const value = vnode.properties[prop];
            event === null
                ? setProperty(prop, value, el)
                : setListener(el, event, value);
        }

        for (const childVNode of vnode.children) {
            const child = create(childVNode);
            el.appendChild(child);
        }

        return el;
    }

    function modify(el, diff) {
        if (diff.d) {  // delete/remove
            for (const prop of diff.d) {
                const event = eventName(prop);
                if (event === null) {
                    removeProperty(prop, el);
                } else {
                    el.removeAttribute('on' + event);
                }
            }
        }

        if (diff.s) {  // set
            for (const prop in diff.s) {
                const value = diff.s[prop];
                const event = eventName(prop);
                event === null
                    ? setProperty(prop, value, el)
                    : setListener(el, event, value);
            }
        }

        if (diff.c) {  // children
            assert(
                el.tagName === 'BODY' || el.tagName === 'HEAD' || diff.c.length >= el.childNodes.length,
                'unmatched children lengths for tag:', el.tagName
            );
            apply(el, diff.c);
        }
    }

    function apply(el, childrenDiff) {
        const children = Array.from(el.childNodes);

        let deletedCount = 0;
        childrenDiff.forEach((diff, i) => {
            i -= deletedCount;
            const action = Object.keys(diff)[0];
            switch (action) {
                case 'd':  // delete/remove
                    children[i + deletedCount].remove();
                    deletedCount += 1;
                    break;

                case 'm':  // modify
                    modify(children[i], diff.m);
                    break;

                case 'n': {  // new/create
                    assert(
                        i >= children.length,
                        'adding to the middle of children',
                        i,
                        children.length
                    );
                    const child = create(diff.n);
                    el.appendChild(child);
                    break;
                }

                case 'r': {  // replace
                    const child = create(diff.r);
                    children[i].replaceWith(child);
                    break;
                }

                case undefined:  // noop
                    break;

                default:
                    throw new Error('Unexpected diff option: ' + Object.keys(diff));
            }
        });
    }

    function executeActionJs(obj) {
        for (const key in obj) {
            // Ensure the property belongs to the object itself, not its prototype chain
            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                continue;
            }

            const value = obj[key];
            if (typeof value === 'object' && value !== null) {
                executeActionJs(value);
            } else if (typeof value === 'string' && value.startsWith('JS:')) {
                obj[key] = eval(value.substring(3));
            }
        }
    }

    let lastDispatch = Promise.resolve();

    async function dispatch(action) {
        // Queue dispatch to avoid dispatching while processing previous response stream
        await lastDispatch;
        lastDispatch = dispatchRaw(action);
    }

    async function dispatchRaw(action) {
        executeActionJs(action);
        action.cid = SOLV_CID;

        try {
            const res = await fetch('/action', { method: 'POST', body: JSON.stringify(action) });
            if (!res.ok) {
                console.error('Dispatch response error', res.status);
            } else {
                const reader = res.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let result = '';
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    result += chunk;
                    const CHUNK_BEGIN = '|CHUNK_BEGIN>';
                    const CHUNK_END = '<CHUNK_END|';
                    let chunkEndIdx = result.indexOf(CHUNK_END);
                    while (chunkEndIdx >= 0) {
                        assert(result.startsWith(CHUNK_BEGIN));
                        const diff = JSON.parse(result.substring(CHUNK_BEGIN.length, chunkEndIdx));
                        console.log('diff:', JSON.stringify(diff, null, 2));
                        apply(document.childNodes[0], diff);
                        result = result.substring(chunkEndIdx + CHUNK_END.length);
                        // Find next chunk
                        chunkEndIdx = result.indexOf(CHUNK_END);
                    }
                }
            }
        } catch (error) {
            console.error('Error dispatching', error);
        }
    }

    // Pull latest (also keep alive) from server every 15s
    setInterval(() => dispatch({t: 'SOLV_KA'}), 15000);
</script>

</html>